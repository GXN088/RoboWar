# RoboWar
Пример использования **абстрактных классов**, **интерфейсов** и **перечисления (реализованного как класс с константами)** для создания простой, но расширяемой модели.

### Общая архитектура

Программа моделирует пошаговую битву двух роботов. Каждый ход один робот атакует, а другой защищается. Логика атаки и защиты циклическая и зависит от внутреннего счетчика.

---

### 1. Интерфейсы (`Attackable`, `Defensable`)

Это основа системы. Они определяют **контракт** (что должны делать объекты), но не реализацию (как они это делают).

*   `Attackable`: Говорит, что объект, который его реализует, должен уметь атаковать (`attack()`), возвращая часть тела.
*   `Defensable`: Говорит, что объект должен уметь защищаться (`defense()`), возвращая часть тела.

Это хорошая практика, так как она разделяет обязанности. В будущем можно создать класс, который только атакует, но не защищается, реализовав только `Attackable`.

---

### 2. Класс `BodyPart`

Это **паттерн "Перечисление" (enum)**, реализованный вручную (до появления `enum` в Java 1.5). Его ключевые особенности:

*   **Константы**: `HEAD`, `LEG`, `ARM`, `CHEST` — это единственно возможные экземпляры этого класса.
*   **Приватный конструктор**: Нельзя создать новый экземпляр `BodyPart` извне. Это гарантирует, что частей тела будет ровно столько, сколько объявлено.
*   **Поле `bodyPart`**: Хранит читаемое название части тела ("нога", "голова").
*   **Метод `toString()`**: Возвращает это читаемое название, что позволяет легко выводить объекты в `System.out.println`.

**Замечание**: В современном Java следовало бы использовать настоящий `enum`:
```java
public enum BodyPart {
    ARM("рука"), HEAD("голова"), LEG("нога"), CHEST("грудь");

    private String bodyPart;

    BodyPart(String bodyPart) {
        this.bodyPart = bodyPart;
    }

    @Override
    public String toString() {
        return bodyPart;
    }
}
```

---

### 3. Абстрактный класс `AbstractRobot`

Это **сердце логики** программы. Он реализует интерфейсы и содержит основную функциональность, которую наследуют конкретные роботы.

*   **Поле `hitCount`**: Это **состояние** робота. Именно этот счетчик определяет, какую часть тела он будет атаковать или защищать в следующий раз. Важно, что это поле **не статическое**, значит у каждого робота свой собственный счетчик. Если бы оно было `static`, все роботы использовали бы один общий счетчик, и их поведение было бы синхронизировано (что неверно).

#### Логика метода `attack()`:
Увеличивает `hitCount` на 1 и возвращает часть тела по циклу:
1 -> `ARM`
2 -> `HEAD`
3 -> `LEG`
4+ -> Сбрасывает счетчик в 0 и возвращает `CHEST` (а так как 0+1=1, следующий удар снова будет в `ARM`).
Цикл: **Рука -> Голова -> Нога -> Грудь -> (сброс) -> Рука -> ...**

#### Логика метода `defense()`:
Увеличивает `hitCount` на 2 и возвращает часть тела по своему циклу:
*После увеличения:*
1 -> `HEAD`
2 -> `LEG`
3 -> `CHEST`
4+ -> Сбрасывает счетчик в 0 и возвращает `ARM`
Из-за шага в +2 цикл защиты сбивается относительно цикла атаки.

**Ключевая проблема кода:** Оба метода (`attack()` и `defense()`) используют **одно и то же поле `hitCount`**. Это приводит к тому, что акт защиты влияет на последующую атаку этого же робота, и наоборот. Это может быть как задуманной фичей (робот "устает" или "теряет концентрацию"), так и багом, если подразумевалась независимость действий.

---

### 4. Конкретный класс `Robot`

Конкретная реализация робота. Он:
1.  Наследует всю логику атаки и защиты от `AbstractRobot`.
2.   Добавляет собственное состояние — `name`.
3.   Реализует геттер для имени.

Класс очень лаконичен благодаря наследованию. Вся сложная логика инкапсулирована в абстрактном классе.

---

### 5. Класс `Solution` с методом `main`

Здесь происходит симуляция боя.

*   Создаются два робота с именами.
*   В цикле вызывается `doMove(robotFirst, robotSecond)`.
*   **`doMove`**:
    1.  `robotFirst.attack()` — первый робот выбирает, куда атаковать. Его внутренний `hitCount` увеличивается.
    2.  `robotSecond.defense()` — второй робот выбирает, как защищаться. *Его* внутренний `hitCount` также увеличивается.
    3.  Результаты выводятся на экран.

---

### Возможный вывод программы (первые несколько ходов):

1.  `Амиго атаковал робота Сгибальщик-02, атакована рука, защищена голова` (Amigo.hitCount=1, Enemy.hitCount=2)
2.  `Амиго атаковал робота Сгибальщик-02, атакована голова, защищена нога` (Amigo.hitCount=2, Enemy.hitCount=4 -> сброс на 0, защита - рука)
3.  `Сгибальщик-02 атаковал робота Амиго, атакована рука, защищена грудь` (Enemy.hitCount=1, Amigo.hitCount=3)
... и так далее.

### Итоговый анализ

**Плюсы:**
1.  **Хорошая архитектура**: Четкое разделение на интерфейсы, абстрактный и конкретный классы.
2.  **Инкапсуляция**: Логика атаки/защиты скрыта в `AbstractRobot`. Главный метод只知道 что роботы могут атаковать и защищаться, но не как именно.
3.  **Повторное использование кода**: Класс `Robot` очень простой, вся функциональность унаследована.
4.  **Состояние объекта**: Каждый робот имеет свое собственное состояние (`hitCount`), что правильно.

**Минусы / Возможные точки улучшения:**
1.  **Общее поле `hitCount`** для атаки и защиты является главным спорным моментом. Это делает поведение неочевидным.
2.  **Жесткая логика**: Цикл атаки и защиты предопределен. Чтобы его изменить, нужно менять код самого `AbstractRobot`. Более гибким решением было бы использовать, например, стратегии.
3.  **"Магические числа"**: Цифры 1, 2, 3 в условиях. Лучше было бы вынести их в константы с понятными именами.
4.  **Избыточность кода**: Классы `BodyPart` и `AbstractRobot` вставлены в листинг дважды
